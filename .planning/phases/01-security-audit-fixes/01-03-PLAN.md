---
phase: 01-security-audit-fixes
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - server/middleware/rate-limit.ts
  - server/middleware/rate-limiter.ts
  - server/middleware/__tests__/rate-limit.test.ts
  - server/middleware/__tests__/rate-limiter.test.ts
autonomous: true
requirements:
  - SEC-04

must_haves:
  truths:
    - "All 8 rate limiters use Redis store when Redis is available"
    - "Rate limiters gracefully fall back to in-memory when Redis is not available"
    - "Rate limiter state persists across application restarts (via Redis)"
  artifacts:
    - path: "server/middleware/rate-limit.ts"
      provides: "5 rate limiters with Redis store"
      contains: "createRedisStore"
    - path: "server/middleware/rate-limiter.ts"
      provides: "3 rate limiters with Redis store"
      contains: "createRedisStore"
    - path: "server/middleware/__tests__/rate-limit.test.ts"
      provides: "Tests verifying Redis store is used in rate-limit.ts limiters"
    - path: "server/middleware/__tests__/rate-limiter.test.ts"
      provides: "Tests verifying Redis store is used in rate-limiter.ts limiters"
  key_links:
    - from: "server/middleware/rate-limit.ts"
      to: "server/lib/redis.ts"
      via: "import { getRedisClient } from '../lib/redis'"
      pattern: "getRedisClient"
    - from: "server/middleware/rate-limiter.ts"
      to: "server/lib/redis.ts"
      via: "import { getRedisClient } from '../lib/redis'"
      pattern: "getRedisClient"
    - from: "server/middleware/rate-limit.ts"
      to: "rate-limit-redis"
      via: "import { RedisStore } from 'rate-limit-redis'"
      pattern: "RedisStore"
---

<objective>
Add Redis persistence to all 8 rate limiters across two files (SEC-04). Rate limit counters must survive pm2 restarts.

Purpose: Currently all rate limiters use in-memory storage, which resets on every pm2 restart -- allowing attackers to bypass rate limits by triggering a restart. Redis-backed storage persists counters across restarts.

Output: All 8 rate limiters use RedisStore when Redis is available, with graceful fallback to in-memory when Redis is not configured. TDD-verified.
</objective>

<execution_context>
@/Users/aleksandrmishin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aleksandrmishin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-audit-fixes/01-RESEARCH.md

@server/middleware/rate-limit.ts
@server/middleware/rate-limiter.ts
@server/lib/redis.ts
@server/middleware/__tests__/rate-limit.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install rate-limit-redis and write RED tests</name>
  <files>
    server/middleware/__tests__/rate-limit.test.ts
    server/middleware/__tests__/rate-limiter.test.ts
  </files>
  <action>
**Step 1: Install rate-limit-redis**

Run `npm install rate-limit-redis` in the project root. This package is already in package.json but not in node_modules (verified). Version 4.3.1 expected.

**Step 2: Write failing tests**

**Update existing file: `server/middleware/__tests__/rate-limit.test.ts`**

Keep existing tests (they verify limiters are defined and callable). ADD new test cases:

```typescript
describe('Redis Store Integration', () => {
  it('rate-limit.ts should import and use RedisStore from rate-limit-redis', () => {
    // Read the source file
    const source = fs.readFileSync(
      path.resolve(__dirname, '../rate-limit.ts'), 'utf-8'
    );
    // Assert it imports RedisStore
    expect(source).toContain("from 'rate-limit-redis'");
    // Assert each limiter uses the store factory
    expect(source).toContain("createRedisStore('rl:auth:");
    expect(source).toContain("createRedisStore('rl:ai:");
    expect(source).toContain("createRedisStore('rl:general:");
    expect(source).toContain("createRedisStore('rl:strict:");
    expect(source).toContain("createRedisStore('rl:heavy:");
  });

  it('should define a createRedisStore helper function', () => {
    const source = fs.readFileSync(
      path.resolve(__dirname, '../rate-limit.ts'), 'utf-8'
    );
    expect(source).toContain('function createRedisStore');
    expect(source).toContain('getRedisClient');
  });
});
```

These tests MUST FAIL because current `rate-limit.ts` has no Redis imports.

**Create new file: `server/middleware/__tests__/rate-limiter.test.ts`**

Same pattern:
```typescript
describe('Redis Store Integration', () => {
  it('rate-limiter.ts should import and use RedisStore', () => {
    const source = fs.readFileSync(
      path.resolve(__dirname, '../rate-limiter.ts'), 'utf-8'
    );
    expect(source).toContain("from 'rate-limit-redis'");
    expect(source).toContain("createRedisStore('rl:api:");
    expect(source).toContain("createRedisStore('rl:auth2:");
    expect(source).toContain("createRedisStore('rl:ai2:");
  });

  it('should define a createRedisStore helper function', () => {
    const source = fs.readFileSync(
      path.resolve(__dirname, '../rate-limiter.ts'), 'utf-8'
    );
    expect(source).toContain('function createRedisStore');
    expect(source).toContain('getRedisClient');
  });
});
```

Also add basic smoke tests: each limiter is defined and is a function.

Run tests and confirm the Redis Store Integration tests FAIL (RED).

**Note on prefix naming:** Use distinct prefixes for each limiter to avoid counter collisions. For `rate-limiter.ts` use `rl:api:`, `rl:auth2:`, `rl:ai2:` (the "2" suffix distinguishes from `rate-limit.ts` limiters that use `rl:auth:` and `rl:ai:`).
  </action>
  <verify>Run `npx vitest run server/middleware/__tests__/rate-limit.test.ts server/middleware/__tests__/rate-limiter.test.ts` -- Redis Store Integration tests must FAIL. Existing smoke tests should still pass.</verify>
  <done>rate-limit-redis is installed. Test files have Redis store assertions that fail against current code (no Redis store used). Existing tests preserved.</done>
</task>

<task type="auto">
  <name>Task 2: GREEN -- Add Redis store to all 8 rate limiters</name>
  <files>
    server/middleware/rate-limit.ts
    server/middleware/rate-limiter.ts
  </files>
  <action>
**Fix both files to use RedisStore. Use the same `createRedisStore` pattern in each file.**

The `createRedisStore` function is simple and used in only these two files. Per the "junior-friendly, explicit, no magic" principle, define it in each file rather than creating a shared module (keeps files self-contained). If the function were used in 3+ places, extract it -- but 2 uses is fine per project conventions.

**File 1: `server/middleware/rate-limit.ts`**

Add imports at the top:
```typescript
import { RedisStore } from 'rate-limit-redis';
import type { RedisReply } from 'rate-limit-redis';
import { getRedisClient } from '../lib/redis';
```

Add the factory function before the first limiter:
```typescript
/**
 * Create Redis store for rate limiter
 * Returns undefined if Redis is not available (falls back to in-memory)
 */
function createRedisStore(prefix: string): RedisStore | undefined {
  const client = getRedisClient();
  if (!client) return undefined;
  return new RedisStore({
    sendCommand: (command: string, ...args: string[]) =>
      client.call(command, ...args) as Promise<RedisReply>,
    prefix,
  });
}
```

Add `store` property to each of the 5 limiters:
- `authRateLimiter`: `store: createRedisStore('rl:auth:'),`
- `aiRateLimiter`: `store: createRedisStore('rl:ai:'),`
- `generalRateLimiter`: `store: createRedisStore('rl:general:'),`
- `strictRateLimiter`: `store: createRedisStore('rl:strict:'),`
- `heavyOperationRateLimiter`: `store: createRedisStore('rl:heavy:'),`

**File 2: `server/middleware/rate-limiter.ts`**

Add the same imports and factory function. Add `store` to each of the 3 limiters:
- `apiLimiter`: `store: createRedisStore('rl:api:'),`
- `authLimiter`: `store: createRedisStore('rl:auth2:'),`
- `aiLimiter`: `store: createRedisStore('rl:ai2:'),`

**Important:** Keep files under 200 lines. `rate-limit.ts` is currently 113 lines, adding ~20 lines for imports + factory = ~133 lines (OK). `rate-limiter.ts` is 63 lines, adding ~20 = ~83 lines (OK).

After changes, run tests to confirm GREEN. Then run full suite.
  </action>
  <verify>
Run `npx vitest run server/middleware/__tests__/rate-limit.test.ts server/middleware/__tests__/rate-limiter.test.ts` -- ALL tests must PASS.
Run `npx vitest run` -- no new failures.
Run `npx tsc --noEmit` -- must pass.
  </verify>
  <done>
SEC-04: All 8 rate limiters use RedisStore with unique prefixes.
Graceful fallback: if Redis is not connected, `createRedisStore` returns `undefined` and express-rate-limit uses in-memory store.
All tests pass. TypeScript compiles clean. Files stay under 200 lines.
  </done>
</task>

</tasks>

<verification>
- `grep "RedisStore" server/middleware/rate-limit.ts server/middleware/rate-limiter.ts` shows both files import and use RedisStore
- `grep "createRedisStore" server/middleware/rate-limit.ts server/middleware/rate-limiter.ts` shows factory function in both
- `grep "getRedisClient" server/middleware/rate-limit.ts server/middleware/rate-limiter.ts` shows Redis client usage
- Count 8 `store:` lines across both files (5 in rate-limit.ts, 3 in rate-limiter.ts)
- `wc -l server/middleware/rate-limit.ts server/middleware/rate-limiter.ts` -- both under 200 lines
- `npx vitest run` -- no new failures
- `npx tsc --noEmit` -- clean
</verification>

<success_criteria>
- All 8 rate limiters have `store: createRedisStore(...)` with unique prefixes (SEC-04)
- Redis store creation is graceful (returns undefined if Redis unavailable)
- Both files import from rate-limit-redis and ../lib/redis
- Files remain under 200 lines
- All tests pass via TDD
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-audit-fixes/01-03-SUMMARY.md`
</output>
