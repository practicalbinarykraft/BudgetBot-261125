/**
 * Enterprise-grade Notification Service
 * Centralized notification system for budget limits, alerts, and user communication
 * Supports Telegram notifications with future email/SMS extensibility
 */

import { logger } from './logger';
import { storage } from './storage';
import type { BudgetLimit, Partner, DailyTransaction } from '@shared/schema';

// Notification types for structured messaging
export interface NotificationPayload {
  userId: number;
  partnerId: number;
  type: 'BUDGET_LIMIT_WARNING' | 'BUDGET_LIMIT_EXCEEDED' | 'RECURRING_TRANSACTION_PROCESSED' | 'GOAL_MILESTONE' | 'PURCHASE_REMINDER';
  title: string;
  message: string;
  metadata?: {
    limitId?: number;
    categoryName?: string;
    currentAmount?: number;
    limitAmount?: number;
    percentage?: number;
    transactionId?: number;
    goalId?: number;
    purchaseId?: number;
    purchaseTitle?: string;
    purchaseAmount?: number;
    targetDate?: string;
    daysUntil?: number;
  };
  urgency: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
}

// Budget limit threshold configuration
const BUDGET_THRESHOLDS = {
  WARNING: 80,    // 80% - yellow warning
  CRITICAL: 100,  // 100% - red alert
} as const;

export class NotificationService {
  private telegramBot: any = null;
  
  constructor() {
    // Import telegram bot dynamically to avoid circular dependencies
    this.initializeTelegramBot();
  }

  private async initializeTelegramBot() {
    try {
      // Import bot instance from telegram-bot module
      const { bot } = await import('./telegram-bot.js');
      this.telegramBot = bot;
      logger.info('Notification service: Telegram bot integration initialized');
    } catch (error) {
      logger.error('Failed to initialize Telegram bot for notifications', error as Error);
    }
  }

  /**
   * Check and send budget limit notifications
   * Called after transaction creation to verify spending against limits
   */
  async checkBudgetLimits(userId: number, transactionAmount: number, categoryId?: number): Promise<void> {
    try {
      // Get user's budget limits (user-centric architecture)
      const budgetLimits = await storage.getBudgetLimits(userId);
      if (budgetLimits.length === 0) return;

      // Get current month spending by category
      const currentDate = new Date();
      const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
      const endOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);

      for (const limit of budgetLimits) {
        // Skip if category doesn't match transaction (when category is specified)
        if (categoryId && limit.categoryId && limit.categoryId !== categoryId) {
          continue;
        }

        // Calculate current spending for this category using existing method (user-centric)
        const transactions = await storage.getDailyTransactions(
          userId,
          startOfMonth.toISOString().split('T')[0], // YYYY-MM-DD format
          endOfMonth.toISOString().split('T')[0]
        );

        const categorySpending = transactions
          .filter((t: any) => t.categoryId === limit.categoryId && t.amount < 0) // Only expenses
          .reduce((sum: number, t: any) => sum + Math.abs(Number(t.amount)), 0);

        // Update budget limit spent amount (only if we have new spending)
        if (transactionAmount < 0 && categorySpending > 0 && limit.categoryId) {
          await storage.updateBudgetLimitSpent(Number(limit.categoryId), userId, Math.abs(transactionAmount));
        }

        // Calculate percentage
        const percentage = (categorySpending / Number(limit.monthlyLimit)) * 100;

        // Check thresholds and send notifications
        await this.processBudgetThreshold(limit, percentage, categorySpending);
      }

      logger.info('Budget limits check completed', {
        userId,
        transactionAmount,
        categoryId,
        limitsChecked: budgetLimits.length
      });
    } catch (error) {
      logger.error('Error checking budget limits', error as Error, {
        userId,
        transactionAmount,
        categoryId
      });
    }
  }

  /**
   * Process budget threshold notifications
   */
  private async processBudgetThreshold(
    limit: BudgetLimit,
    percentage: number,
    currentSpending: number
  ): Promise<void> {
    try {
      // Avoid spam - only notify at specific thresholds
      const shouldNotifyWarning = percentage >= BUDGET_THRESHOLDS.WARNING && percentage < BUDGET_THRESHOLDS.CRITICAL;
      const shouldNotifyCritical = percentage >= BUDGET_THRESHOLDS.CRITICAL;

      if (!shouldNotifyWarning && !shouldNotifyCritical) return;

      // Get category name for better messaging  
      const category = limit.categoryId ? await storage.getCategory(Number(limit.categoryId)) : null;
      const categoryName = category?.name || '–û–±—â–∏–µ';

      // Get partner and user info
      const partner = await storage.getPartner(Number(limit.partnerId));
      if (!partner) return;

      const user = await storage.getUser(Number(partner.userId));
      if (!user) return;

      // Prepare notification payload
      const payload: NotificationPayload = {
        userId: user.id,
        partnerId: partner.id,
        type: shouldNotifyCritical ? 'BUDGET_LIMIT_EXCEEDED' : 'BUDGET_LIMIT_WARNING',
        title: shouldNotifyCritical ? 'üö® –õ–∏–º–∏—Ç –ø—Ä–µ–≤—ã—à–µ–Ω!' : '‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ –ª–∏–º–∏—Ç–µ',
        message: this.formatBudgetMessage(categoryName, currentSpending, Number(limit.monthlyLimit), percentage),
        metadata: {
          limitId: limit.id,
          categoryName,
          currentAmount: currentSpending,
          limitAmount: Number(limit.monthlyLimit),
          percentage: Math.round(percentage)
        },
        urgency: shouldNotifyCritical ? 'CRITICAL' : 'HIGH'
      };

      // Send notification
      await this.sendNotification(payload);

      // Log alert sent to prevent duplicates (lastAlertSent field will be added later)
      logger.info('Budget limit alert sent', {
        limitId: limit.id,
        partnerId: limit.partnerId,
        percentage: Math.round(percentage),
        alertType: shouldNotifyCritical ? 'CRITICAL' : 'WARNING'
      });

    } catch (error) {
      logger.error('Error processing budget threshold', error as Error, {
        limitId: limit.id,
        percentage
      });
    }
  }

  /**
   * Format budget limit message for user
   */
  private formatBudgetMessage(
    categoryName: string,
    currentSpending: number,
    limitAmount: number,
    percentage: number
  ): string {
    const formattedSpending = new Intl.NumberFormat('ru-RU', {
      style: 'currency',
      currency: 'USD'
    }).format(currentSpending);

    const formattedLimit = new Intl.NumberFormat('ru-RU', {
      style: 'currency',
      currency: 'USD'
    }).format(limitAmount);

    if (percentage >= 100) {
      return `–õ–∏–º–∏—Ç –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ "${categoryName}" –ø—Ä–µ–≤—ã—à–µ–Ω –Ω–∞ ${Math.round(percentage - 100)}%!\n\n–¢—Ä–∞—Ç—ã: ${formattedSpending}\n–õ–∏–º–∏—Ç: ${formattedLimit}\n\n–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º –ø–µ—Ä–µ—Å–º–æ—Ç—Ä–µ—Ç—å —Ä–∞—Å—Ö–æ–¥—ã –≤ —ç—Ç–æ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∏.`;
    } else {
      return `–ü—Ä–∏–±–ª–∏–∂–∞–µ—Ç—Å—è –ª–∏–º–∏—Ç –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ "${categoryName}" (${Math.round(percentage)}%).\n\n–¢—Ä–∞—Ç—ã: ${formattedSpending}\n–õ–∏–º–∏—Ç: ${formattedLimit}\n\n–û—Å—Ç–∞—Ç–æ–∫: ${new Intl.NumberFormat('ru-RU', { style: 'currency', currency: 'USD' }).format(limitAmount - currentSpending)}`;
    }
  }

  /**
   * Send notification through available channels
   */
  async sendNotification(payload: NotificationPayload): Promise<boolean> {
    try {
      let sent = false;

      // Try Telegram first
      if (this.telegramBot) {
        const telegramSent = await this.sendTelegramNotification(payload);
        sent = sent || telegramSent;
      }

      // Future: Add email notifications here
      // const emailSent = await this.sendEmailNotification(payload);
      // sent = sent || emailSent;

      // Audit log
      logger.info('Notification sent', {
        userId: payload.userId,
        success: sent,
        type: payload.type,
        urgency: payload.urgency,
        telegramAttempted: !!this.telegramBot,
        metadata: payload.metadata
      });

      return sent;
    } catch (error) {
      logger.error('Error sending notification', error as Error, {
        userId: payload.userId,
        type: payload.type
      });
      return false;
    }
  }

  /**
   * Send Telegram notification
   */
  private async sendTelegramNotification(payload: NotificationPayload): Promise<boolean> {
    try {
      if (!this.telegramBot) return false;

      // Get user's Telegram chat ID
      const user = await storage.getUser(payload.userId);
      if (!user?.telegramId) return false;

      // Format message for Telegram
      const telegramMessage = `${payload.title}\n\n${payload.message}`;

      // Send through telegram service
      const result = await this.telegramBot.sendMessage(user.telegramId, telegramMessage);

      logger.info('Telegram notification sent', {
        userId: payload.userId,
        chatId: user.telegramId,
        type: payload.type
      });

      return !!result;
    } catch (error) {
      logger.error('Failed to send Telegram notification', error as Error, {
        userId: payload.userId,
        type: payload.type
      });
      return false;
    }
  }

  /**
   * Send recurring transaction notification
   */
  async notifyRecurringTransaction(
    partnerId: number,
    transactionAmount: number,
    description: string,
    categoryName?: string
  ): Promise<void> {
    try {
      const partner = await storage.getPartner(partnerId);
      if (!partner) return;

      const user = await storage.getUser(partner.userId);
      if (!user) return;

      const formattedAmount = new Intl.NumberFormat('ru-RU', {
        style: 'currency',
        currency: 'USD'
      }).format(Math.abs(transactionAmount));

      const transactionType = transactionAmount > 0 ? '–¥–æ—Ö–æ–¥' : '—Ä–∞—Å—Ö–æ–¥';
      const categoryText = categoryName ? ` –≤ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ "${categoryName}"` : '';

      const payload: NotificationPayload = {
        userId: user.id,
        partnerId: partner.id,
        type: 'RECURRING_TRANSACTION_PROCESSED',
        title: 'üí∞ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è',
        message: `–û–±—Ä–∞–±–æ—Ç–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π ${transactionType} ${formattedAmount}${categoryText}.\n\n–û–ø–∏—Å–∞–Ω–∏–µ: ${description}`,
        metadata: {
          currentAmount: transactionAmount,
          categoryName
        },
        urgency: 'LOW'
      };

      await this.sendNotification(payload);
    } catch (error) {
      logger.error('Error sending recurring transaction notification', error as Error, {
        partnerId,
        transactionAmount
      });
    }
  }

  /**
   * Send purchase reminder notification
   */
  async notifyPurchaseReminder(
    purchaseId: number,
    partnerId: number,
    purchaseTitle: string,
    purchaseAmount: number,
    targetDate: string,
    daysUntil: number
  ): Promise<void> {
    try {
      const partner = await storage.getPartner(partnerId);
      if (!partner) return;

      const user = await storage.getUser(partner.userId);
      if (!user) return;

      const formattedAmount = new Intl.NumberFormat('ru-RU', {
        style: 'currency',
        currency: 'USD'
      }).format(purchaseAmount);

      // Format date in Russian
      const dateObj = new Date(targetDate);
      const formattedDate = dateObj.toLocaleDateString('ru-RU', { 
        day: 'numeric', 
        month: 'long', 
        year: 'numeric' 
      });

      // Different messages based on days until
      let title: string;
      let message: string;
      let urgency: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';

      if (daysUntil === 0) {
        title = 'üéØ –°–µ–≥–æ–¥–Ω—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞ –ø–æ–∫—É–ø–∫–∞!';
        message = `–°–µ–≥–æ–¥–Ω—è –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞ –ø–æ–∫—É–ø–∫–∞ "${purchaseTitle}" –Ω–∞ —Å—É–º–º—É ${formattedAmount}.\n\n–ù–µ –∑–∞–±—É–¥—å—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –∏–ª–∏ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –ø–æ–∫—É–ø–∫—É –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏.`;
        urgency = 'HIGH';
      } else if (daysUntil === 1) {
        title = '‚è∞ –ó–∞–≤—Ç—Ä–∞ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞ –ø–æ–∫—É–ø–∫–∞';
        message = `–ó–∞–≤—Ç—Ä–∞ (${formattedDate}) –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞ –ø–æ–∫—É–ø–∫–∞ "${purchaseTitle}" –Ω–∞ —Å—É–º–º—É ${formattedAmount}.\n\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–ª–∏—á–∏–µ —Å—Ä–µ–¥—Å—Ç–≤ –∏ –ø–æ–¥–≥–æ—Ç–æ–≤—å—Ç–µ—Å—å –∫ –ø–æ–∫—É–ø–∫–µ.`;
        urgency = 'MEDIUM';
      } else {
        title = `üìÖ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –æ –ø–æ–∫—É–ø–∫–µ —á–µ—Ä–µ–∑ ${daysUntil} –¥–Ω—è`;
        message = `–ß–µ—Ä–µ–∑ ${daysUntil} –¥–Ω—è (${formattedDate}) –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞ –ø–æ–∫—É–ø–∫–∞ "${purchaseTitle}" –Ω–∞ —Å—É–º–º—É ${formattedAmount}.\n\n–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —É –≤–∞—Å –±—É–¥–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤.`;
        urgency = 'LOW';
      }

      const payload: NotificationPayload = {
        userId: user.id,
        partnerId: partner.id,
        type: 'PURCHASE_REMINDER',
        title,
        message,
        metadata: {
          purchaseId,
          purchaseTitle,
          purchaseAmount,
          targetDate,
          daysUntil
        },
        urgency
      };

      await this.sendNotification(payload);
      
      logger.info('Purchase reminder sent', {
        purchaseId,
        partnerId,
        daysUntil,
        targetDate
      });
    } catch (error) {
      logger.error('Error sending purchase reminder notification', error as Error, {
        purchaseId,
        partnerId,
        daysUntil
      });
    }
  }
}

// Export singleton instance
export const notificationService = new NotificationService();