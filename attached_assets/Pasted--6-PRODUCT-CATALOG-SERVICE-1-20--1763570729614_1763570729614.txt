ğŸ“Š Ğ¨ĞĞ“ 6: PRODUCT CATALOG SERVICE - Ğ§ĞĞ¡Ğ¢Ğ¬ 1 (20 Ğ¼Ğ¸Ğ½ÑƒÑ‚)â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Ğ—ĞĞ”ĞĞ§Ğ 6.1: Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ Ğ‘ĞĞ—ĞĞ’Ğ«Ğ™ SERVICE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ Ğ¤ĞĞ™Ğ›: server/services/product-catalog.service.ts

Ğ¡ĞĞ”Ğ•Ğ Ğ–Ğ˜ĞœĞĞ•:

import { productCatalogRepository } from '../repositories/product-catalog.repository';
import { productPriceHistoryRepository } from '../repositories/product-price-history.repository';

// ĞĞ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°
export function normalizeName(name: string): string {
  return name
    .toLowerCase()
    .trim()
    .replace(/[^Ğ°-Ña-z0-9\s]/g, '') // ÑƒĞ±Ñ€Ğ°Ñ‚ÑŒ ÑĞ¿ĞµÑ†ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹
    .replace(/\s+/g, ' '); // ÑƒĞ±Ñ€Ğ°Ñ‚ÑŒ Ğ»Ğ¸ÑˆĞ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ±ĞµĞ»Ñ‹
}

// Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ÑŒ Ğ±Ñ€ĞµĞ½Ğ´ Ğ¸Ğ· Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ (Ğ¿Ñ€Ğ¾ÑÑ‚Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°)
export function extractBrand(name: string): string | null {
  // Ğ˜Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğµ Ğ±Ñ€ĞµĞ½Ğ´Ñ‹ (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€Ğ¸Ñ‚ÑŒ)
  const brands = [
    'barilla', 'Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ĞºĞ²Ğ°ÑˆĞ¸Ğ½Ğ¾', 'nestle', 'coca-cola', 
    'pepsi', 'danone', 'Ğ¼Ğ°ĞºÑ„Ğ°', 'heinz', 'knorr'
  ];
  
  const normalized = name.toLowerCase();
  
  for (const brand of brands) {
    if (normalized.includes(brand)) {
      return brand.charAt(0).toUpperCase() + brand.slice(1);
    }
  }
  
  return null;
}

// Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ÑŒ Ğ²ĞµÑ/Ğ¾Ğ±ÑŠÑ‘Ğ¼ Ğ¸Ğ· Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ñ
export function extractWeight(name: string): string | null {
  // ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½Ñ‹: 500Ğ³, 1ĞºĞ³, 1Ğ», 500Ğ¼Ğ»
  const weightPattern = /(\d+(?:\.\d+)?)\s*(Ğ³|ĞºĞ³|Ğ»|Ğ¼Ğ»|ÑˆÑ‚)/i;
  const match = name.match(weightPattern);
  
  if (match) {
    return match[0]; // "500Ğ³"
  }
  
  return null;
}

// ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¸Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ² ĞºĞ°Ñ‚Ğ°Ğ»Ğ¾Ğ³Ğµ
export async function findOrCreateProduct(params: {
  name: string;
  userId: number;
  category?: string;
}): Promise<number> {
  const normalizedName = normalizeName(params.name);
  
  // ĞŸĞ¾Ğ¿Ñ‹Ñ‚Ğ°Ñ‚ÑŒÑÑ Ğ½Ğ°Ğ¹Ñ‚Ğ¸ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‰Ğ¸Ğ¹
  let product = await productCatalogRepository.findByNormalizedName(
    normalizedName, 
    params.userId
  );
  
  if (product) {
    return product.id;
  }
  
  // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹
  const brand = extractBrand(params.name);
  const weight = extractWeight(params.name);
  
  product = await productCatalogRepository.create({
    userId: params.userId,
    name: params.name,
    normalizedName,
    brand,
    weight,
    category: params.category,
    purchaseCount: 0
  });
  
  return product.id;
}

// ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ»ÑƒÑ‡ÑˆÑƒÑ Ñ†ĞµĞ½Ñƒ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°
export async function updateBestPrice(productId: number): Promise<void> {
  // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ñ†ĞµĞ½Ñ‹
  const prices = await productPriceHistoryRepository.findByProduct(productId);
  
  if (prices.length === 0) return;
  
  // ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ»ÑƒÑ‡ÑˆÑƒÑ (Ğ¼Ğ¸Ğ½Ğ¸Ğ¼Ğ°Ğ»ÑŒĞ½ÑƒÑ)
  const best = prices.reduce((min, p) => 
    parseFloat(p.price) < parseFloat(min.price) ? p : min
  );
  
  // Ğ Ğ°ÑÑÑ‡Ğ¸Ñ‚Ğ°Ñ‚ÑŒ ÑÑ€ĞµĞ´Ğ½ÑÑ
  const sum = prices.reduce((acc, p) => acc + parseFloat(p.price), 0);
  const avg = sum / prices.length;
  
  // ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€
  await productCatalogRepository.update(productId, {
    bestPrice: best.price,
    bestStore: best.storeName,
    averagePrice: avg.toFixed(2)
  });
}

Ğ¡Ğ¢Ğ ĞĞš: ~95 âœ…
ĞĞ¢Ğ’Ğ•Ğ¢Ğ¡Ğ¢Ğ’Ğ•ĞĞĞĞ¡Ğ¢Ğ¬: Ğ‘Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ ÑƒÑ‚Ğ¸Ğ»Ğ¸Ñ‚Ñ‹ Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ñ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°Ğ¼Ğ¸ âœ…

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞ«Ğ™ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢:
âœ… Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğ¹
âœ… Ğ˜Ğ·Ğ²Ğ»ĞµÑ‡ĞµĞ½Ğ¸Ğµ Ğ±Ñ€ĞµĞ½Ğ´Ğ° Ğ¸ Ğ²ĞµÑĞ°
âœ… ĞŸĞ¾Ğ¸ÑĞº/ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°
âœ… ĞĞ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ»ÑƒÑ‡ÑˆĞµĞ¹ Ñ†ĞµĞ½Ñ‹