ğŸ“‹ Ğ¨ĞĞ“ 2: PRODUCT CATALOG REPOSITORY (20 Ğ¼Ğ¸Ğ½ÑƒÑ‚)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Ğ—ĞĞ”ĞĞ§Ğ 2.1: Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ REPOSITORY Ğ”Ğ›Ğ¯ PRODUCT CATALOG
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ Ğ¤ĞĞ™Ğ›: server/repositories/product-catalog.repository.ts

Ğ¡ĞĞ”Ğ•Ğ Ğ–Ğ˜ĞœĞĞ•:

import { eq, and, like, desc, sql } from 'drizzle-orm';
import { db } from '../db';
import { productCatalog, type InsertProductCatalog, type ProductCatalog } from '@shared/schema';

class ProductCatalogRepository {
  // ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ²ÑĞµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ñ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
  async findByUser(userId: number): Promise<ProductCatalog[]> {
    return await db
      .select()
      .from(productCatalog)
      .where(eq(productCatalog.userId, userId))
      .orderBy(desc(productCatalog.purchaseCount));
  }

  // ĞĞ°Ğ¹Ñ‚Ğ¸ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ¿Ğ¾ ID
  async findById(id: number): Promise<ProductCatalog | null> {
    const results = await db
      .select()
      .from(productCatalog)
      .where(eq(productCatalog.id, id))
      .limit(1);
    
    return results[0] || null;
  }

  // ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾ Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ¼Ñƒ Ğ¸Ğ¼ĞµĞ½Ğ¸
  async findByNormalizedName(normalizedName: string, userId: number): Promise<ProductCatalog | null> {
    const results = await db
      .select()
      .from(productCatalog)
      .where(
        and(
          eq(productCatalog.normalizedName, normalizedName),
          eq(productCatalog.userId, userId)
        )
      )
      .limit(1);
    
    return results[0] || null;
  }

  // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€
  async create(data: InsertProductCatalog): Promise<ProductCatalog> {
    const results = await db
      .insert(productCatalog)
      .values(data)
      .returning();
    
    return results[0];
  }

  // ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€
  async update(id: number, data: Partial<InsertProductCatalog>): Promise<ProductCatalog> {
    const results = await db
      .update(productCatalog)
      .set({ ...data, updatedAt: new Date() })
      .where(eq(productCatalog.id, id))
      .returning();
    
    return results[0];
  }

  // Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€
  async delete(id: number): Promise<void> {
    await db
      .delete(productCatalog)
      .where(eq(productCatalog.id, id));
  }

  // Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡Ğ¸Ñ‚ÑŒ ÑÑ‡Ñ‘Ñ‚Ñ‡Ğ¸Ğº Ğ¿Ğ¾ĞºÑƒĞ¿Ğ¾Ğº
  async incrementPurchaseCount(id: number): Promise<void> {
    await db
      .update(productCatalog)
      .set({
        purchaseCount: sql`${productCatalog.purchaseCount} + 1`,
        lastPurchaseDate: new Date().toISOString().split('T')[0],
        updatedAt: new Date()
      })
      .where(eq(productCatalog.id, id));
  }

  // ĞŸĞ¾Ğ¸ÑĞº Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ²
  async search(userId: number, query: string): Promise<ProductCatalog[]> {
    const searchPattern = `%${query.toLowerCase()}%`;
    
    return await db
      .select()
      .from(productCatalog)
      .where(
        and(
          eq(productCatalog.userId, userId),
          like(productCatalog.normalizedName, searchPattern)
        )
      )
      .orderBy(desc(productCatalog.purchaseCount));
  }

  // Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ Ğ¿Ğ¾ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸
  async findByCategory(userId: number, category: string): Promise<ProductCatalog[]> {
    return await db
      .select()
      .from(productCatalog)
      .where(
        and(
          eq(productCatalog.userId, userId),
          eq(productCatalog.category, category)
        )
      )
      .orderBy(desc(productCatalog.purchaseCount));
  }
}

export const productCatalogRepository = new ProductCatalogRepository();

ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞ«Ğ™ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢:
âœ… Repository ÑĞ¾Ğ·Ğ´Ğ°Ğ½ Ñ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¼Ğ¸ CRUD Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ°Ğ¼Ğ¸
âœ… ĞŸĞ¾Ğ¸ÑĞº Ğ¸ Ñ„Ğ¸Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚
âœ… TypeScript Ñ‚Ğ¸Ğ¿Ñ‹ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹