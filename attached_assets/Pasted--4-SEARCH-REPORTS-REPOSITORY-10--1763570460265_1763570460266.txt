ğŸ“‹ Ğ¨ĞĞ“ 4: SEARCH REPORTS REPOSITORY (10 Ğ¼Ğ¸Ğ½ÑƒÑ‚)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Ğ—ĞĞ”ĞĞ§Ğ 4.1: Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ REPOSITORY Ğ”Ğ›Ğ¯ SEARCH REPORTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Ğ¡ĞĞ—Ğ”ĞĞ¢Ğ¬ Ğ¤ĞĞ™Ğ›: server/repositories/price-search-reports.repository.ts

Ğ¡ĞĞ”Ğ•Ğ Ğ–Ğ˜ĞœĞĞ•:

import { eq, and, desc } from 'drizzle-orm';
import { db } from '../db';
import { 
  priceSearchReports, 
  type InsertPriceSearchReport, 
  type PriceSearchReport 
} from '@shared/schema';

class PriceSearchReportsRepository {
  // ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚Ñ‹ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°
  async findByProduct(productId: number): Promise<PriceSearchReport[]> {
    return await db
      .select()
      .from(priceSearchReports)
      .where(eq(priceSearchReports.productId, productId))
      .orderBy(desc(priceSearchReports.searchDate));
  }

  // ĞĞ°Ğ¹Ñ‚Ğ¸ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚
  async findLatest(productId: number): Promise<PriceSearchReport | null> {
    const results = await db
      .select()
      .from(priceSearchReports)
      .where(
        and(
          eq(priceSearchReports.productId, productId),
          eq(priceSearchReports.status, 'completed')
        )
      )
      .orderBy(desc(priceSearchReports.searchDate))
      .limit(1);
    
    return results[0] || null;
  }

  // Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚
  async create(data: InsertPriceSearchReport): Promise<PriceSearchReport> {
    const results = await db
      .insert(priceSearchReports)
      .values(data)
      .returning();
    
    return results[0];
  }

  // ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚
  async update(id: number, data: Partial<InsertPriceSearchReport>): Promise<PriceSearchReport> {
    const results = await db
      .update(priceSearchReports)
      .set(data)
      .where(eq(priceSearchReports.id, id))
      .returning();
    
    return results[0];
  }

  // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ ĞµÑÑ‚ÑŒ Ğ»Ğ¸ ÑĞ²ĞµĞ¶Ğ¸Ğ¹ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚ (< 3 Ğ´Ğ½ĞµĞ¹)
  async hasRecentReport(productId: number, daysAgo: number = 3): Promise<boolean> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysAgo);
    
    const results = await db
      .select()
      .from(priceSearchReports)
      .where(
        and(
          eq(priceSearchReports.productId, productId),
          eq(priceSearchReports.status, 'completed')
        )
      )
      .orderBy(desc(priceSearchReports.searchDate))
      .limit(1);
    
    if (!results[0]) return false;
    
    return new Date(results[0].searchDate) > cutoffDate;
  }
}

export const priceSearchReportsRepository = new PriceSearchReportsRepository();

ĞĞ–Ğ˜Ğ”ĞĞ•ĞœĞ«Ğ™ Ğ Ğ•Ğ—Ğ£Ğ›Ğ¬Ğ¢ĞĞ¢:
âœ… Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚Ğ°Ğ¼Ğ¸ Ğ¿Ğ¾Ğ¸ÑĞºĞ°
âœ… ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ²ĞµĞ¶ĞµÑÑ‚Ğ¸ Ğ¾Ñ‚Ñ‡Ñ‘Ñ‚Ğ¾Ğ²
âœ… Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ¾Ğ²